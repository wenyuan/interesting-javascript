# JavaScript深入之闭包

> 对[作用域](https://github.com/winyuan/head-frist-javascript/blob/master/articles/深入系列/JavaScript深入之作用域.md)工作原理有了一定的理解后，就可以开始深入学习闭包了。

## 一、什么是闭包

#### 1. 当函数可以**记住并访问**所在的词法作用域时，就产生了闭包。

#### 2. 举个例子：

```javascript
function foo() {
  var a = 2
  
  function bar() {
    console.log(a)
  }
  
  return bar
}

var baz = foo()
baz() // 2
```

上例中，我们将 `bar` 引用的函数对象本身当作返回值。此时，虽然 `bar()` 函数**在自己定义的词法作用域以外的地方执行**，但 `bar()` 依然持有对  `foo` 内部作用域的引用，**这个引用就叫作闭包**。  

拜 `bar()` 所声明的位置所赐，它拥有涵盖 `foo` 内部作用域的闭包，使得该作用域能够一直存活，以供 `bar()` 在之后任何时间进行引用。（否则在 `foo()` 执行后，引用的垃圾回收器会释放不再使用的内存空间）

#### 3. 闭包使得函数可以在其它地方（定义时的词法作用域以外的地方）继续访问定义时的词法作用域。

#### 4. 无论通过何种手段将内部函数**传递**到所在词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。  

举个例子：
把内部函数 `baz` 传递给 `bar`，当调用这个内部函数时 （也就是 `fn`），它涵盖的 `foo()` 内部作用域的闭包就可以使用到了，因为它能够访问 `a`。

```javascript
function foo() {
  var a = 2
  
  function baz() {
    console.log(a)
  }
  
  bar(baz)
}

function bar(fn) {
  fn() // 这就是闭包
}

foo() // 2
```

再举个例子，间接传递函数：

```javascript
var fn

function foo() {
  var a = 2
  
  function baz() {
    console.log(a)
  }
  
  fn = baz // 将 baz 分配给全局变量
}

function bar() {
  fn() // 这就是闭包
}

foo()
bar() // 2
```

#### 5. 在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者其他的异步（或者同步）任务中，**只要使用了回调函数**，实际上就是在使用闭包。

#### 6. 严格意义上讲，立即执行函数（IIFE）不是闭包。  
因为函数（下例中的 `IIFE`）并不是在它本身的词法作用域以外执行的，它在定义时所在的作用域中执行，`a` 是通过普通的词法作用域查找而非闭包被发现的。

## 二、循环和闭包（进阶）

看下面的例子，猜猜输出什么？
```javascript
for (var i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i*1000)
}
```
答案是以每秒一次的频率输出五次 6。  
原因是**延迟函数的回调会在循环结束时才执行**，所以就算定时器运行时每个迭代中执行的是 `setTimeout(..., 0)`，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。  

上述代码中，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都**被封闭在一个共享的全局作用域中**，因此实际上只有一个 `i`。  

**解决方法**：  
1） **IIFE** 会通过声明并立即执行一个函数来创建作用域；

2）在每次迭代中，`IIFE` 都会创建一个词法作用域且被延迟函数封闭起来，但**每个作用域还需要有自己的变量**，用来在每个迭代中存储 `i` 的值。

```javascript
for (var i=1; i<=5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j*1000)
  })(i)
}
```

**总结**：  
在迭代内使用 **IIFE** 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。

## 三、块作用域 + 闭包（常用）

上面的解决方案主要用于分析原理，在实际开发中，我们最常见的就是用 `let` 关键字在块作用域中声明一个变量。

于是上面的代码可以变得很简单。

```javascript
for (let i=1; i<=5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i*1000)
}
```
