# JavaScript深入之this关键字

> this 关键字是 JavaScript 中最复杂的机制之一，它是一个很特别的关键字，被自动定义在所有函数的作用域中。

## 一、关于 this
1. 两种常见的对于 `this` 的**错误解释**：  
    ~~``this`` 指向函数自身。~~  
    ~~``this`` 指向函数的词法作用域。~~  

2. ``this`` 是在**运行时**进行绑定的，并不是在编程时绑定。  

3. ``this`` 是在函数被调用时被绑定的，完全取决于函数的**调用位置**。


## 二、调用位置
1. 调用栈  
    寻找函数被调用地位置，最重要的是要分析**调用栈**（就是为了到达当前执行位置所调用的所有函数），调用位置就在当前正在执行的函数的前一个调用中。  

2. 可以通过浏览器的调试工具查看调用栈：给目标函数的第一行代码设置断点，或者直接在目标函数的第一行代码之前插入一条 `debugger` 语句。


## 三、绑定规则
&emsp;&emsp;要知道**调用位置如何决定 `this` 的绑定对象**，就要在找到调用位置后，依据四条规则来判断。  
&emsp;&emsp;下面来介绍这四条规则。

## 四、四条规则
1. 默认规则  
    最常用的函数调用类型：**独立函数调用**。可以把这条规则看作是无法应用其他规则时的默认规则。  

    如下代码所示，`foo` 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。
```javascript
function foo() {
  console.log(this.a)
}

var a = 2
foo()
```

2. 隐式绑定  
    调用位置有上下文对象，或者说调用位置被某个对象拥有或者包含。  

    如下代码所示，调用位置会使用 `obj` 上下文来引用函数；但无论是直接在 `obj` 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 `obj` 对象，**仅是调用位置会使用 `obj` 上下文来引用函数**。  

    当函数引用引用有上下文对象时，隐式绑定规则会把函数调用中的 `this` 绑定到这个上下文对象。
```javascript
function foo() {
  console.log(this.a)
}

var obj = {
  a: 2,
  foo: foo
}

obj.foo() // 2
```
&emsp;&emsp;对象属性引用链中只有上一层或者说最后一层再调用位置中起作用，举例：
```javascript
function foo() {
  console.log(this.a)
}

var obj2 = {
  a: 42,
  foo: foo
}

var obj1 = {
  a: 2,
  obj2: obj2
}

obj1.obj2.foo(); // 42
```
&emsp;&emsp;需要注意**隐式丢失** 的问题。（此类问题暂不总结）

3. 显示绑定  
    