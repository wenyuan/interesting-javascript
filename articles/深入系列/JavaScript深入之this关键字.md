# JavaScript深入之this关键字

> this 关键字是 JavaScript 中最复杂的机制之一，它是一个很特别的关键字，被自动定义在所有函数的作用域中。

## 一、关于 this
1. 两种常见的对于 `this` 的**错误解释**：  
    ~~``this`` 指向函数自身。~~  
    ~~``this`` 指向函数的词法作用域。~~  

2. ``this`` 是在**运行时**进行绑定的，并不是在编程时绑定。  

3. ``this`` 是在函数被调用时被绑定的，完全取决于函数的**调用位置**。


## 二、调用位置
1. 调用栈  
    寻找函数被调用地位置，最重要的是要分析**调用栈**（就是为了到达当前执行位置所调用的所有函数），调用位置就在当前正在执行的函数的前一个调用中。  

2. 可以通过浏览器的调试工具查看调用栈：给目标函数的第一行代码设置断点，或者直接在目标函数的第一行代码之前插入一条 `debugger` 语句。


## 三、绑定规则
&emsp;&emsp;要知道**调用位置如何决定 `this` 的绑定对象**，就要在找到调用位置后，依据四条规则来判断。  
&emsp;&emsp;下面来介绍这四条规则。


## 四、四条规则
1. **默认规则**  
    最常用的函数调用类型：**独立函数调用**。可以把这条规则看作是无法应用其他规则时的默认规则。  

    如下代码所示，`foo` 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。
```javascript
function foo() {
  console.log(this.a)
}

var a = 2
foo()
```

2. **隐式绑定**  
    调用位置有上下文对象，或者说调用位置被某个对象拥有或者包含。  

    如下代码所示，调用位置会使用 `obj` 上下文来引用函数；但无论是直接在 `obj` 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 `obj` 对象，**仅是调用位置会使用 `obj` 上下文来引用函数**。  

    当函数引用引用有上下文对象时，隐式绑定规则会把函数调用中的 `this` 绑定到这个上下文对象。
```javascript
function foo() {
  console.log(this.a)
}

var obj = {
  a: 2,
  foo: foo
}

obj.foo() // 2
```
&emsp;&emsp;对象属性引用链中只有上一层或者说最后一层再调用位置中起作用，举例：
```javascript
function foo() {
  console.log(this.a)
}

var obj2 = {
  a: 42,
  foo: foo
}

var obj1 = {
  a: 2,
  obj2: obj2
}

obj1.obj2.foo(); // 42
```
&emsp;&emsp;需要注意**隐式丢失** 的问题。（此类问题暂不总结）

3. **显示绑定**  
    无需在对象内部包含函数引用，也就是使用 `call(...)` 和 `apply(...)` 方法。（JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用这两个方法）  
    
    **这两个方法的第一个参数都是一个对象，是给 `this` 准备的**，接着在调用函数时将其绑定到 `this`。因为你可以直接指定 `this` 的绑定对象，因为称之为显示绑定。  
    
    如下例，通过 `foo.call(...)`，我们可以在调用 `foo` 时强制把它的 `this` 绑定到 `obj` 上。
```javascript
function foo() {
  console.log(this.a)
}

var obj = {
  a: 2
}

foo.call(obj) // 2
```

4. **new绑定**  
    包括内置对象函数（比如 `Number(...)`）在内的所有函数都可以用 `new` 来调用，这种函数调用被称为构造函数调用。（这里的“构造函数”指对于函数的“构造调用”，有别于其他编程语言的“类构造函数”）  
    
    使用 `new` 来调用函数，会自动执行下面的操作：  
    **① 创建（或者说构造）一个全新的对象；**  
    ② 这个新对象会被执行 `[[Prototype]]` 连接；  
    **③ 这个新对象会绑定到函数调用的 `this`；**  
    **④ 如果函数没有返回其他对象，那么 `new` 表达式中的函数调用会自动返回这个新对象。**  
    
    如下例，使用 `new` 来调用 `foo(...)` 时，会构造一个新对象并把它绑定到 `foo(...)` 调用中的 `this` 上。  
```javascript
function foo(a) {
  this.a = a
}

var bar = new foo(2)
console.log(bar.a) // 2
```


## 五、绑定规则优先级  
&emsp;&emsp;前面说过，我们需要找到函数的调用位置并判断应当应用哪条规则，进行判断出 `this` 的绑定对象。  
&emsp;&emsp;但是当某个调用位置可以应用多条规则是，就有如下优先级：  

&emsp;&emsp;① 函数是否在 `new` 中调用（`new` 绑定）？如果是的话 `this` 绑定的是新创建的对象。
```javascript
var bar = new foo()
```
&emsp;&emsp;② 函数是否通过 `call`、`apply`（显式绑定）或者硬绑定调用？如果是的话`this` 绑定的是指定的对象。
```javascript
var bar = foo.call(obj2)
```
&emsp;&emsp;③ 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话 `this` 绑定的是那个上下文对象。
```javascript
var bar = obj1.foo()
```
&emsp;&emsp;④ 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 `undefined`，否则绑定到全局对象。
```javascript
var bar = foo()
```


## 六、ES6 中的箭头函数
&emsp;&emsp;箭头函数不使用 `this` 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 `this`。
