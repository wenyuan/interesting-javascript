# JavaScript深入之作用域

> 从 JavaScript 编译原理展开，深入理解 JavaScript 的作用域、词法作用域、函数作用域和块作用域。

## 一、编译原理

#### 1. JavaScript 是一门编译语言
与传统编译语言略有不同，它不是提前编译的。但 JavaScript 引擎进行编译的步骤和传统编译语言非常相似。

#### 2. 传统编译过程
* **分词/词法分析（Tokenizing/Lexing）**  
  这个过程将字符串（例如 `var a = 2;` ）分解成有意义的代码块( `var`, `a`, `=`, `2`, `;` )，这些代码块被称为词法单元（token）。
* **解析/语法分析（Parsing）**  
  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
* **代码生成**  
  将AST转换为可执行代码的过程。

#### 3. JavaScript 编译特点
对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微妙（甚至更短）。  
JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。 

## 二、作用域

#### 1. 参与程序处理的三个成员
* **引擎**  
  从头到尾负责整个 JavaScript 程序的编译及执行过程。
* **编译器**  
  负责语法分析及代码生成。  
* **作用域**  
  用于确定在何处以及如何查找变量（标识符）的一套规则。

#### 2. 引擎查找变量的方式
* 如果查找的目的是对变量进行赋值，那么就会使用 **LHS** 查询；
* 如果查找的目的是获取变量的值，就会使用 **RHS** 查询；
* 赋值操作符会导致 **LHS** 查询，`=` 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

#### 3. 变量赋值的过程拆解（`var a = 2;`）
在代码执行前，首先编译器会在当前作用域中声明一个变量（`var a`）（如果之前没有声明过），在运行时，引擎会在作用域中查询（LHS 查询）变量 `a` 并对其进行赋值。

#### 4. 异常  
* 如果 RHS 查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出 `ReferenceError` 异常；  
* 如果LHS查询在所有嵌套的作用域中都找不到所需的变量，全局作用域中就会自动隐式地创建一个具有该名称的变量（非严格模式），或者抛出 `ReferenceError` 异常（严格模式下）；  
* 如果 RHS 查询找到了一个变量，但是你对这个变量的值进行不合理的操作，引擎就会抛出 `TypeError` 异常。

## 三、词法作用域

#### 1. 词法作用域就是定义在词法阶段的作用域。（词法阶段：编译的第一个阶段，将字符串分解成单词）

#### 2. 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。

#### 3. 作用域的查找会在找到第一个匹配的标识符时停止。（在多层嵌套作用域中，由内向外找）

#### 4. **遮蔽效应**
在多层嵌套作用域中，定义了同名的标识符，内部标识符”遮蔽了”外部标识符。

#### 5. **全局变量会自动成为全局对象的属性**，所以可以通过 `window.a` 的方式访问被同名变量所遮蔽的全局变量。（浏览器中的 `window` 对象就是一个全局对象）

#### 6. JavaScript 中有两个机制可以“欺骗”词法作用域：`eval(...)` 和 `with`，但都不建议使用。
* 原因一：会导致性能下降。因为在编译阶段，JavaScript无法确认 `eval(...)` 中的代码和传递给 `with` 的内容，所以引擎无法在编译时对作用域查找进行优化。
* 原因二：`eval(...)` 和 `with` 会被严格模式所影响，甚至禁止。

#### 7. `eval` 代码示例
`eval(...)` 函数可以接受一个字符串为参数，并将其中的内容（代码）当作本来就在那里的一样来处理。

```javascript
function foo(str, a) {
  eval(str) // 欺骗
  console.log(a, b)
}

var b = 2
foo('var b = 3', 1) // 1, 3
```

#### 8. `with` 代码示例
`with` 可以作为引用同一个对象的快捷方式，使用 `with` 就不需要重复引用对象本身。

```javascript
var obj1 = {
  a: 1,
  b: 2,
  c: 3
}

// 重复的引用了obj
obj.a = 2
obj.b = 3
obj.c = 4

// 使用with当作快捷方式
with (obj) {
  a = 3
  b = 4
  c = 5
}
```
但是会有变量泄露到全局作用域问题：
```javascript
function foo(obj) {
  with (obj) {
    a = 2
  }
}

var o1 = {
  a: 3
}

var o2 = {
  b: 3
}

foo(o1)
console.log(o1.a) // 2

foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2 —— a被泄露到全局作用域上了！
```
当我们传递 `o2` 给 `with` 时，`with` 所声明的作用域是 `o2`，其中并没有 `a` 标识符，因此进行了正常的 **LHS 标识符查询**，接下来由于`o2`作用域、`foo(...)`作用域和全局作用域中都没有找到标识符`a`，所以当 `a = 2` 执行时，就自动创建了一个全局变量（非严格模式）。

## 四、函数作用域

#### 1. 函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。（事实上在嵌套的作用域中也可以使用）

#### 2. **隐藏内部实现**：即把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。  
**好处**：  
① 遵循最小特权原则（也叫最小授权或最小暴露原则），在软件设计中，应该最小限度地暴露必要内容；  
② 可以避免同名标识符之间的冲突；

#### 3. **函数声明** 和 **函数表达式**  
如果 `function` 关键字出现在声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

```javascript
// 函数声明
function foo() {
  var a = 3
  console.log(a)
}
foo()

// 函数表达式
(function foo() {
  var a = 3
  console.log(a)
})()
```

函数声明和函数表达式之间最重要的区别是它们的名称标识符会绑定在何处。

```javascript
// 函数声明：foo被绑定在所在作用域中，可以直接通过foo()来调用它
function foo() { ... }

// 函数表达式：foo被绑定在函数表达式自身的函数中，避免了污染外部作用域
(function foo() { ... })
```

#### 4. **匿名** 和 **具名**
```javascript
// 匿名函数表达式
setTimeout(function() {
  console.log('I waited 1 second!')
}, 1000)

// 具名函数表达式
setTimeout(function timeoutHandler() {
  console.log('I waited 1 second!')
}, 1000)
```
**Tips：**  
① 函数表达式可以是匿名的，而函数声明不可以省略函数名。  
② 始终给函数表达式命名时一个最佳实践。

#### 5. 立即执行函数表达式
**立即执行函数表达式（IIFE）** 是社区定义的一个术语（Immediately Invoked Function Expression）。  
函数被包含在一对`( )`括号内部，就成为了一个表达式，通过在表达式末尾加上另外一个 `( )` 可以立即执行这个函数。比如 `(function foo(){...})()`。

#### 6. 立即执行函数表达式的三种形式
```javascript
// 带函数名的IIFE
(function foo() {
  console.log('带函数名的IIFE')
})()

// 匿名的IIFE
(function() {
  console.log('匿名的IIFE')
})()

// 用来调用的()括号被移到用来包装的()括号中
(function() {
  console.log('用来调用的()括号被移到用来包装的()括号中')
}())
```

#### 7. 把IIFE当作函数调用并传递参数进去
```javascript
var a = 2
(function IIFE(global) {
  var a = 3
  console.log(a) // 3
  console.log(global.a) // 2
})(window)

console.log(a) // 2
```

## 五、块作用域

#### 1. 块作用域是一个用来对之前的**最小授权原则**进行扩展的工具，将代码从在函数中隐藏信息扩展为在块中隐藏信息。

#### 2. 下面的代码，`i` 会被绑定在外部作用域（函数或全局）中。因为当使用 `var` 声明变量时，它写在哪里都是一样的，最终都会属于外部作用域。

```javascript
for (var i=0;i<10;i++) {
  console.log(i)
}
```

#### 3. **with**
    前面讨论过 `with` 关键字，用 `with` 从对象中创建出的作用域仅在 `with` 声明中而非外部作用域中有效。

#### 4. **try/catch**
JavaScript的ES3规范中规定 **try/catch**的 `catch` 分句会创建一个块作用域，其中声明的变量仅在 `catch` 内部有效。

（但当同一个作用域中的两个或多个 `catch` 分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出告警。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会很烦人地发出告警。对于这种情况，可以将 `catch` 地参数命名为 `err1`、`err2`等）

#### 5. **let**
`let` 是ES6引入的关键字，可以将变量绑定到所在的任意作用域中（通常是 `{ ... }` 内部）。

使用 `let` 声明的代码在被运行之前，声明并不“存在”，如下代码示例：

```javascript
{
  console.log(bar) // ReferenceError!
  let bar = 2
}
```

#### 6. **const**
`const` 也是ES6引入的关键词，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

```javascript
var foo = true
if (foo) {
  var a = 2
  const b = 3 // 包含在if中的块作用域常量
  
  a = 3 // 正常！
  b = 4 // 错误！
}

console.log(a) // 3
console.log(b) // ReferenceError!
```

## 六、提升
#### 1. 什么是提升
在JavaScript中，无论作用域中的声明出现在声明地方，在编译阶段都会将**变量和函数声明**从它们在代码中出现的位置被“移动”到最上面。

#### 2. 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。

```javascript
a = 2
var a
console.log(a) // 2
```

#### 3. JavaScript会将一个声明赋值语句（`var a = 2`）看成两个声明：`var a` 和 `a = 2`。
第一个定义声明是在编译阶段进行的，第二个赋值声明会被**留在原地**等待执行阶段。

```javascript
console.log(a) // undefined
var a = 2
```

#### 4. 函数声明会被提升，但是函数表达式却不会被提升。  
下面代码中 `foo` 是一个函数表达式而不是函数声明，故在执行 `foo()` 时并没有被赋值，对一个 `undefined` 值进行函数调用就导致了非法操作，抛出 TypeError 异常。

```javascript
foo() // 不是 ReferenceError，而是 TypeError!

var foo = function bar() {
  // ...
}
```

#### 5. 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。

```javascript
foo() // TypeError
bar() // ReferenceError

var foo = function bar() {
  // ...
}
```

#### 6. **函数优先** 
函数会首先被提升，然后才是变量。

```javascript
foo()  // 1

var foo

function foo() {
  console.log(1)
}

foo = function() {
  console.log(2)
}
```

上述代码中，尽管 `var foo` 出现在 `function foo(){}` 之前，但它是**重复的声明**（函数声明会被提升到普通变量之前），因此被忽略了 。

#### 7. 重复的var声明会被覆盖掉，但**出现在后面的函数声明还是可以覆盖前面的**。

```javascript
foo() // 3

function foo() {
  console.log(1)
}

var foo = function() {
  console.log(2)
}

function foo() {
  console.log(3)
}
```

#### 8. 综上所述，在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。
