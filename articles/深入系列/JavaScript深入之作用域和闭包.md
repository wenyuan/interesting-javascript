# JavaScript深入之作用域和闭包

> Scope & Closures

## 一、编译原理
1. JavaScript是一门编译语言  
    与传统编译语言略有不同，它不是提前编译的。但JavaScript引擎进行编译的步骤和传统编译语言非常相似。
2. 传统编译过程  
    **分词/词法分析（Tokenizing/Lexing）**  
    这个过程将字符串（例如 `var a = 2;` ）分解成有意义的代码块( `var`, `a`, `=`, `2`, `;` )，这些代码块被称为词法单元（token）。  
    **解析/语法分析（Parsing）**  
    这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。  
    **代码生成**  
    将AST转换为可执行代码的过程。
3. JavaScript编译特点  
    对于JavaScript来说，大部分情况下编译发生在代码执行前的几微妙（甚至更短）。  
    JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。 

## 二、作用域
1. 参与程序处理的三个成员  
    **引擎**  
    从头到尾负责整个JavaScript程序的编译及执行过程。  
    **编译器**  
    负责语法分析及代码生成。  
    **作用域**  
    用于确定在何处以及如何查找变量（标识符）的一套规则。
2. 引擎查找变量的方式  
    如果查找的目的是对变量进行赋值，那么就会使用**LHS**查询，  
    如果查找的目的是获取变量的值，就会使用**RHS**查询。  
    赋值操作符会导致**LHS**查询，`=`操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
3. 变量赋值的过程拆解（`var a = 2;`）  
    在代码执行前，首先编译器会在当前作用域中声明一个变量（`var a`）（如果之前没有声明过），  
    在运行时，引擎会在作用域中查询（LHS查询）变量a并对其进行赋值。
4. 异常  
    如果RHS查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出 `ReferenceError` 异常；  
    如果LHS查询在所有嵌套的作用域中都找不到所需的变量，全局作用域中就会自动隐式地创建一个具有该名称的变量（非严格模式），或者抛出 `ReferenceError` 异常（严格模式下）；  
    如果RHS查询找到了一个变量，但是你对这个变量的值进行不合理的操作，引擎就会抛出 `TypeError` 异常。

## 三、词法作用域
1. 词法作用域就是定义在词法阶段的作用域。（词法阶段：编译的第一个阶段，将字符串分解成单词）
2. 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。
3. 作用域的查找会在找到第一个匹配的标识符时停止。（在多层嵌套作用域中，由内向外找）
4. **遮蔽效应**：在多层嵌套作用域中，定义了同名的标识符，内部标识符”遮蔽了”外部标识符。
5. **全局变量会自动成为全局对象的属性**，所以可以通过 `window.a` 的方式访问被同名变量所遮蔽的全局变量。（浏览器中的 `window` 对象就是一个全局对象）
6. JavaScript中有两个机制可以“欺骗”词法作用域：`eval(...)` 和 `with`，但都不建议使用。  
    原因一：会导致性能下降。因为在编译阶段，JavaScript无法确认 `eval(...)` 中的代码和传递给 `with` 的内容，所以引擎无法在编译时对作用域查找进行优化。  
    原因二：`eval(...)` 和 `with` 会被严格模式所影响，甚至禁止。
7. `eval` 代码示例
    `eval(...)` 函数可以接受一个字符串为参数，并将其中的内容（代码）当作本来就在那里的一样来处理。
```javascript
function foo(str, a) {
  eval(str) // 欺骗
  console.log(a, b)
}

var b = 2
foo('var b = 3', 1) // 1, 3
```
8. `with` 代码示例
    `with` 可以作为引用同一个对象的快捷方式，使用 `with` 就不需要重复引用对象本身。
```javascript
var obj1 = {
  a: 1,
  b: 2,
  c: 3
}

// 重复的引用了obj
obj.a = 2
obj.b = 3
obj.c = 4

// 使用with当作快捷方式
with (obj) {
  a = 3
  b = 4
  c = 5
}
```
&emsp;&emsp;但是会有变量泄露到全局作用域问题：
```javascript
function foo(obj) {
  with (obj) {
    a = 2
  }
}

var o1 = {
  a: 3
}

var o2 = {
  b: 3
}

foo(o1)
console.log(o1.a) // 2

foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2 —— a被泄露到全局作用域上了！
```
&emsp;&emsp;当我们传递 `o2` 给 `with` 时，`with` 所声明的作用域是 `o2`，其中并没有 `a` 标识符，因此进行了正常的**LHS标识符查询**，接下来由于`o2`作用域、`foo(...)`作用域和全局作用域中都没有找到标识符`a`，所以当 `a = 2` 执行时，就自动创建了一个全局变量（非严格模式）。

## 四、函数作用域
1. 函数作用域是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。（事实上在嵌套的作用域中也可以使用）
2. **隐藏内部实现**：即把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。  
    **好处**：  
    ① 遵循最小特权原则（最小暴露原则），在软件设计中，应该最小限度地暴露必要内容；  
    ② 可以避免同名标识符之间的冲突；
3. **函数声明** 和 **函数表达式**
    如果 `function` 关键字出现在声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
```javascript
// 函数声明
function foo() {
  var a = 3
  console.log(a)
}
foo()

// 函数表达式
(function foo() {
  var a = 3
  console.log(a)
})()
```
&emsp;&emsp;函数声明和函数表达式之间最重要的区别是它们的名称标识符会绑定在何处。
```javascript
// 函数声明：foo被绑定在所在作用域中，可以直接通过foo()来调用它
function foo() { ... }

// 函数表达式：foo被绑定在函数表达式自身的函数中，避免了污染外部作用域
(function foo() { ... })
```
4. **匿名** 和 **具名**
```javascript
// 匿名函数表达式
setTimeout(function() {
  console.log('I waited 1 second!')
}, 1000)

// 具名函数表达式
setTimeout(function timeoutHandler() {
  console.log('I waited 1 second!')
}, 1000)
```
&emsp;&emsp;**Tips：**  
&emsp;&emsp;① 函数表达式可以是匿名的，而函数声明不可以省略函数名。  
&emsp;&emsp;② 始终给函数表达式命名时一个最佳实践。

5. 立即执行函数表达式
    **立即执行函数表达式（IIFE）**是社区定义的一个术语（Immediately Invoked Function Expression）。  
    函数被包含在一对`( )`括号内部，就成为了一个表达式，通过在表达式末尾加上另外一个 `( )` 可以立即执行这个函数。比如 `(function foo(){...})()`。
6. 立即执行函数表达式的三种形式
```javascript
// 带函数名的IIFE
(function foo() {
  console.log('带函数名的IIFE')
})()

// 匿名的IIFE
(function() {
  console.log('匿名的IIFE')
})()

// 用来调用的()括号被移到用来包装的()括号中
(function() {
  console.log('用来调用的()括号被移到用来包装的()括号中')
}())
```
7. 把IIFE当作函数调用并传递参数进去
```javascript
var a = 2
(function IIFE(global) {
  var a = 3
  console.log(a) // 3
  console.log(global.a) // 2
})(window)

console.log(a) // 2
```

## 五、块作用域

