# JavaScript深入之作用域和闭包

> Scope & Closures

## 一、编译原理
1. JavaScript是一门编译语言  
    与传统编译语言略有不同，它不是提前编译的。但JavaScript引擎进行编译的步骤和传统编译语言非常相似。
2. 传统编译过程  
    **分词/词法分析（Tokenizing/Lexing）**  
    这个过程将字符串（例如 `var a = 2;` ）分解成有意义的代码块( `var`, `a`, `=`, `2`, `;` )，这些代码块被称为词法单元（token）。  
    **解析/语法分析（Parsing）**  
    这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。  
    **代码生成**  
    将AST转换为可执行代码的过程。
3. JavaScript编译特点  
    对于JavaScript来说，大部分情况下编译发生在代码执行前的几微妙（甚至更短）。  
    JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。 

## 二、作用域
1. 参与程序处理的三个成员  
    **引擎**  
    从头到尾负责整个JavaScript程序的编译及执行过程。  
    **编译器**  
    负责语法分析及代码生成。  
    **作用域**  
    用于确定在何处以及如何查找变量（标识符）的一套规则。
2. 引擎查找变量的方式  
    如果查找的目的是对变量进行赋值，那么就会使用**LHS**查询，  
    如果查找的目的是获取变量的值，就会使用**RHS**查询。  
    赋值操作符会导致**LHS**查询，`=`操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。
3. 变量赋值的过程拆解（`var a = 2;`）  
    在代码执行前，首先编译器会在当前作用域中声明一个变量（`var a`）（如果之前没有声明过），  
    在运行时，引擎会在作用域中查询（LHS查询）变量a并对其进行赋值。
4. 异常  
    如果RHS查询在所有嵌套的作用域中都找不到所需的变量，引擎就会抛出 `ReferenceError` 异常；  
    如果LHS查询在所有嵌套的作用域中都找不到所需的变量，全局作用域中就会自动隐式地创建一个具有该名称的变量（非严格模式），或者抛出 `ReferenceError` 异常（严格模式下）；  
    如果RHS查询找到了一个变量，但是你对这个变量的值进行不合理的操作，引擎就会抛出 `TypeError` 异常。

## 三、词法作用域
1. 词法作用域就是定义在词法阶段的作用域。（词法阶段：编译的第一个阶段，将字符串分解成单词）
2. 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。
3. 作用域的查找会在找到第一个匹配的标识符时停止。（在多层嵌套作用域中，由内向外找）
4. **遮蔽效应**：在多层嵌套作用域中，定义了同名的标识符，内部标识符”遮蔽了”外部标识符。
5. **全局变量会自动成为全局对象的属性**，所以可以通过 `window.a` 的方式访问被同名变量所遮蔽的全局变量。（浏览器中的 `window` 对象就是一个全局对象）
6. JavaScript中有两个机制可以“欺骗”词法作用域：`eval(...)` 和 `with`，但都不建议使用。  
    原因一：会导致性能下降。因为在编译阶段，JavaScript无法确认 `eval(...)` 中的代码和传递给 `with` 的内容，所以引擎无法在编译时对作用域查找进行优化。  
    原因二：`eval(...)` 和 `with` 会被严格模式所影响，甚至禁止。
7. `eval` 代码示例
    `eval(...)` 函数可以接受一个字符串为参数，并将其中的内容（代码）当作本来就在那里的一样来处理。
```javascript
function foo(str, a) {
  eval(str) // 欺骗
  console.log(a, b)
}

var b = 2
foo('var b = 3', 1) // 1, 3
```
8. `with` 代码示例
    `with` 可以作为引用同一个对象的快捷方式，使用 `with` 就不需要重复引用对象本身。
```javascript
var obj1 = {
  a: 1,
  b: 2,
  c: 3
}

// 重复的引用了obj
obj.a = 2
obj.b = 3
obj.c = 4

// 使用with当作快捷方式
with (obj) {
  a = 3
  b = 4
  c = 5
}
```
&emsp;&emsp;但是会有变量泄露到全局作用域问题：
```javascript
function foo(obj) {
  with (obj) {
    a = 2
  }
}

var o1 = {
  a: 3
}

var o2 = {
  b: 3
}

foo(o1)
console.log(o1.a) // 2

foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2 —— a被泄露到全局作用域上了！
```
&emsp;&emsp;当我们传递 `o2` 给 `with` 时，`with` 所声明的作用域是 `o2`，其中并没有 `a` 标识符，因此进行了正常的**LHS标识符查询**，接下来由于`o2`作用域、`foo(...)`作用域和全局作用域中都没有找到标识符`a`，所以当 `a = 2` 执行时，就自动创建了一个全局变量（非严格模式）。

## 四、函数作用域
